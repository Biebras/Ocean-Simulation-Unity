#pragma kernel CalculateInitSpectrum
#pragma kernel CalculateFrequencyDomain
#pragma kernel CalculateHeight

#define PI 3.14159265359
#define G 9.81

// ====== Inputs ======
uint Size; // M and N
uint LengthScale;

//Spectrum settings
float Amplitude;
float WindSpeed;
float2 WindDirection;
float Depth;
float Time;
float DisplacementFactor;

// Gaussian noise
Texture2D Noise;

// ====== Outputs ======
RWTexture2D<float4> InitSpectrum;
RWTexture2D<float4> FrequencyDomain;
RWTexture2D<float4> WaveData;
RWTexture2D<float4> HeightMap;
RWTexture2D<float4> NormalMap;


float PhillipsSpectrum(float2 waveVector)
{
    float L = WindSpeed * WindSpeed / G;
    float l = L / 2000000;
    
    float kLength = length(waveVector);

    if(kLength < 0.0001)
        return 0;
    
    float dominator = exp(-1 / (kLength * kLength * L * L));
    float nominator = kLength * kLength * kLength * kLength;
    float k_dot_w = dot(normalize(waveVector), WindDirection);
    float surpression = exp(-kLength * kLength * l * l);
    float k_dot_w_6 = k_dot_w * k_dot_w * k_dot_w * k_dot_w * k_dot_w * k_dot_w;
    float result = 0.000001 * Amplitude * dominator / nominator * k_dot_w_6 * surpression; 
    
    return result;
}

float WaveDispertion(float kLength)
{
    return sqrt(G * kLength * tanh(min(kLength * Depth, 20)));
    //return sqrt(G * kLength);
}

float2 FourierWaveAmplitude(float2 pos, float2 k)
{
    float2 rand = float2(Noise[pos.xy].x, Noise[pos.xy].y);

    return 1 / sqrt(2) * rand * sqrt(PhillipsSpectrum(k));
}

float2 FourierWaveAmplitudeConj(float2 pos, float2 k)
{
    float2 rand = float2(Noise[pos.xy].z, Noise[pos.xy].w);

    return 1 / sqrt(2) * rand * sqrt(PhillipsSpectrum(k));
}

float2 WaveVector(float2 pos)
{
    float n = Size / 2;
    float k_x = 2 * PI * (pos.x - n) / LengthScale;
    float k_z = 2 * PI * (pos.y - n) / LengthScale;
    
    return float2(k_x, k_z);
}

float2 EulerFormula(float x)
{
    return float2(cos(x), sin(x));
}

float2 ComplexMult(float2 a, float2 b)
{
    float2 result;
    result.x = a.x * b.x - a.y * b.y;
    result.y = a.x * b.y + a.y * b.x;
    return result;
}

[numthreads(8,8,1)]
void CalculateInitSpectrum (uint3 id : SV_DispatchThreadID)
{
    float2 k = WaveVector(id.xy);
    float kLength = length(k);
    float dispertion = WaveDispertion(kLength);
    
    float2 h_0 = FourierWaveAmplitude(id.xy, k);
    float2 h_1 = FourierWaveAmplitudeConj(id.xy, -k); 
    
    InitSpectrum[id.xy] = float4(h_0.x, h_0.y, h_1.x, h_1.y);
    WaveData[id.xy] = float4(k.x, k.y, dispertion, 1);
}

[numthreads(8,8,1)]
void CalculateFrequencyDomain (uint3 id : SV_DispatchThreadID)
{
    float2 h_0 = InitSpectrum[id.xy].xy;
    float2 h_1 = InitSpectrum[id.xy].zw;
    float dispertion = WaveData[id.xy].z;
    
    // real time
    float phase = dispertion * Time;
    float2 exponent_0 = EulerFormula(phase);
    float2 exponent_1 = EulerFormula(-phase);
    
    float2 firstPart = ComplexMult(h_0, exponent_0);
    float2 secondPart = ComplexMult(h_1, exponent_1);
    float2 h = firstPart + secondPart;
    
    FrequencyDomain[id.xy] = float4(h.x, h.y, 0, 1);
}

[numthreads(8,8,1)]
void CalculateHeight (uint3 id : SV_DispatchThreadID)
{
    float2 height = 0;
    float2 tangent = 0;
    float2 bitangent = 0;
    float2 vectorFieldX = 0;
    float2 vectorFieldZ = 0;
    
    float n = Size / 2;
    float2 pos = float2((id.x - n) * LengthScale / Size, (id.y - n) * LengthScale / Size);
    
    for (int x = 0; x < Size; x++)
    {
        for (int y = 0; y < Size; y++)
        {
            float2 frequencyPos = float2(x, y);
            float2 h = FrequencyDomain[frequencyPos].xy;
            float2 k =  WaveData[frequencyPos].xy;
            float kLength = length(k);
            float2 k_over_length = 0;
            
            if(kLength > 0.0001)
                k_over_length = k / kLength;
    
            float2 exponent = EulerFormula(dot(k, pos));
            float2 result = ComplexMult(h, exponent);
            
            height += result;
            tangent += ComplexMult(float2(0, k.x), result);
            bitangent += ComplexMult(float2(0, k.y), result);
            vectorFieldX += ComplexMult(float2(0, -k_over_length.x), result);
            vectorFieldZ += ComplexMult(float2(0, -k_over_length.y), result);
        }
    }
    
    vectorFieldX *= -DisplacementFactor;
    vectorFieldZ *= -DisplacementFactor;
    
    float3 normal = normalize(float3(-tangent.x, 1, -bitangent.x));
    
    HeightMap[id.xy] = float4(vectorFieldX.x, height.x, vectorFieldZ.x, 1);
    NormalMap[id.xy] = float4(normal.x, normal.y, normal.z, 1);
}