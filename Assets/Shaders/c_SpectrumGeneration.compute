#pragma kernel CalculateSpectrum
#pragma kernel CalculateHeight

#define PI 3.14159265359
#define G 9.81

// Inputs
uint Size; // M and N
uint LengthScale;
float WindSpeed;
float Fetch;
float PeakEnhancementFactor;
float Depth; // later we would want to use texture for this.
Texture2D<float2> Noise;

// Outputs
RWTexture2D<float3> SpectrumMap;
RWTexture2D<float3> HeightMap;

float JONSWAP(float angularFrequency)
{
    float alpha = 0.076 * pow(pow(WindSpeed, 2) / (Fetch * G), 0.22); 
    float peakFrequency = 22 * (pow(G, 2) / (WindSpeed * Fetch));
    float sigma = angularFrequency <= peakFrequency ? 0.07 : 0.09;

    float r_1 = 2 * sigma * sigma * peakFrequency * peakFrequency;
    float r_2 = (angularFrequency - peakFrequency) * (angularFrequency - peakFrequency);
    float r = exp(-r_1 / r_2);

    return alpha * G * G / pow(angularFrequency, 5)
                 * exp(-1.25 * pow(peakFrequency / angularFrequency, 4))
                 * pow(PeakEnhancementFactor, r); 
}

float DepthAttenuation(float angularFrequency, float waterDepth)
{
    // depthAdjustedAngularFrequency
    float w_h = angularFrequency * sqrt(waterDepth/G);
    
    if(w_h <= 1)
        return 0.5 * angularFrequency * w_h * w_h;
    
    if(w_h <= 2)
        return 0.5 * angularFrequency * w_h * w_h * (2 - w_h);

    // clamp to 1
    return 1;
}

float TMA(float angularFrequency, float waterDepth)
{
    return JONSWAP(angularFrequency) * DepthAttenuation(angularFrequency, waterDepth);
}

float WaveDispertion(float kMag)
{
    return sqrt(G * kMag * tanh(min(kMag * Depth, 15)));
}

float WaveAmplitude(float2 pos, float2 k)
{
    float kMagnetude = length(k);
    float angularFrequency = WaveDispertion(kMagnetude);

    float rand1 = Noise[pos.xy].x;
    float rand2 = Noise[pos.xy].y;

    return 1 / sqrt(2) * (rand1 + rand2) * sqrt(TMA(angularFrequency, Depth));
}

float2 WaveVector(float2 pos)
{
    float n = Size / 2;
    float k_x = 2 * PI * (pos.x - n) / LengthScale;
    float k_z = 2 * PI * (pos.y - n) / LengthScale;
    return float2(k_x, k_z);
}

[numthreads(8,8,1)]
void CalculateSpectrum (uint3 id : SV_DispatchThreadID)
{
    // offset to center
    float2 k = WaveVector(id.xy);
    float amplitude = WaveAmplitude(id.xy, k);
    
    SpectrumMap[id.xy] = float3(amplitude, 0, 0);
}

[numthreads(8,8,1)]
void CalculateHeight (uint3 id : SV_DispatchThreadID)
{
    // float sum = 0;
    // float n = Size / 2;
    // float2 pos = float2((id.x - n)*LengthScale/Size, (id.y - n)*LengthScale/Size);
    // //
    // // sum up every frequency from spectrum for each heightmap pixel
    // for(int x = 0; x < Size; x++)
    // {
    //     for (int y = 0; y < Size; y++)
    //     {
    //         float2 k = WaveVector(float2(x,y));
    //         float2 uv = float2(x / (float)Size, y / (float)Size);
    //         
    //         sum += SpectrumMap[uv].r * exp(dot(k, pos));
    //     }
    // }
    
    HeightMap[id.xy] = float3(id.x, 0, 0);
}
