#pragma kernel CalculateSpectrum
#pragma kernel CalculateConjugateSpectrum
#pragma kernel CalculateHeight

#define PI 3.14159265359
#define G 9.81

// ====== Inputs ======
uint Size; // M and N
uint LengthScale;

//Spectrum settings
float WindSpeed;
float2 WindDirection;
float Depth;
float Time;

// Gaussian noise
Texture2D Noise;

// ====== Outputs ======
RWTexture2D<float4> SpectrumMap;
RWTexture2D<float4> HeightMap;


float PhillipsSpectrum(float2 waveVector)
{
    float A = 0.6858;
    float L = WindSpeed * WindSpeed / G;
    float l = L / 2000;
    
    float kLength = length(waveVector);

    if(kLength == 0)
    {
        waveVector = float2(0.0001, 0.0001);
        kLength = length(waveVector);
    }
    
    float dominator = exp(-1 / (kLength * kLength * L * L));
    float nominator = kLength * kLength * kLength * kLength;
    float k_dot_w = dot(normalize(waveVector), WindDirection);
    float surpression = exp(-kLength * kLength * l * l);
    float result = A * dominator / nominator * (k_dot_w * k_dot_w) * surpression; 
    
    return clamp(result, -4000, 4000);
}

float WaveDispertion(float kLength)
{
    return sqrt(G * kLength * tanh(min(kLength * Depth, 20)));
    //return sqrt(G * kLength);
}

float2 FourierWaveAmplitude(float2 pos, float2 k)
{
    float2 rand = float2(Noise[pos.xy].x, Noise[pos.xy].y);

    return 1 / sqrt(2) * rand * sqrt(PhillipsSpectrum(k));
}

float2 FourierWaveAmplitudeConj(float2 pos, float2 k)
{
    float2 rand = float2(Noise[pos.xy].z, Noise[pos.xy].w);

    return 1 / sqrt(2) * rand * sqrt(PhillipsSpectrum(k));
}

float2 WaveVector(float2 pos)
{
    float n = Size / 2;
    float k_x = 2 * PI * (pos.x - n) / LengthScale;
    float k_z = 2 * PI * (pos.y - n) / LengthScale;
    
    return float2(k_x, k_z);
}

float2 EulerFormula(float x)
{
    return float2(cos(x), sin(x));
}

float2 ComplexMult(float2 a, float2 b)
{
    float2 result;
    result.x = a.x * b.x - a.y * b.y;
    result.y = a.x * b.y + a.y * b.x;
    return result;
}

[numthreads(8,8,1)]
void CalculateSpectrum (uint3 id : SV_DispatchThreadID)
{
    float2 k = WaveVector(id.xy);

    // // init
    float2 h_0 = FourierWaveAmplitude(id.xy, k);
    float2 h_1 = FourierWaveAmplitudeConj(id.xy, -k); 
    
    // real time
    float t = Time;
    float dispertion = WaveDispertion(length(k));
    float phase = dispertion * t;
    float2 exponent_0 = EulerFormula(phase);
    float2 exponent_1 = EulerFormula(-phase);
    
    float2 firstPart = ComplexMult(h_0, exponent_0);
    float2 secondPart = ComplexMult(h_1, exponent_1);
    float2 h = firstPart + secondPart;
    
    SpectrumMap[id.xy] = float4(h.x, h.y, 0, 1);
}

[numthreads(8,8,1)]
void CalculateHeight (uint3 id : SV_DispatchThreadID)
{
    float2 sum = 0;
    
    float n = Size / 2;
    float2 pos = float2((id.x - n) * LengthScale / Size, (id.y - n) * LengthScale / Size);
    
    for (int x = 0; x < Size; x++)
    {
        for (int y = 0; y < Size; y++)
        {
            float2 spectrumPos = float2(x, y);
            float2 h = SpectrumMap[spectrumPos].xy;
            float2 k = WaveVector(spectrumPos);
    
            float2 exponent = EulerFormula(dot(k, pos));
            float2 result = ComplexMult(h, exponent);
            
            sum += result;
        }
    }
    
    sum.x = (sum.x + 1500) / 3000;
    
    HeightMap[id.xy] = float4(sum.x, sum.x, sum.x, 1);
}
