#pragma kernel CalculateSpectrum
#pragma kernel CalculateHeight

#define PI 3.14159265359
#define G 9.81

// ====== Inputs ======
uint Size; // M and N
uint LengthScale;

//Spectrum settings
float WindSpeed;
float2 WindDirection;
float Depth;

// Gaussian noise
Texture2D<float2> Noise;

// ====== Outputs ======
RWTexture2D<float4> SpectrumMap;
RWTexture2D<float4> HeightMap;

// float GetAlpha()
// {
//     float nominator = WindSpeed * WindSpeed;
//     float denominator = G * Fetch;
//     return 0.076f * pow(abs(nominator / denominator), 0.22f);
// }

// float GetPeekDispertion()
// {
//     float nominator = G * G;
//     float denominator = WindSpeed * Fetch;
//     return 22 * pow(abs(nominator / denominator), 0.333f);
// }

// float JONSWAP(float dispertion)
// {
//     float peekDispertion = GetPeekDispertion();
//     float sigma = dispertion <= peekDispertion ? 0.07 : 0.09;
//     float rNominator = (dispertion - peekDispertion) * (dispertion - peekDispertion);
//     float rDenominator = 2 * sigma * sigma * peekDispertion * peekDispertion;
//     float r = exp(-rNominator / rDenominator);
//     
//     float firstPart = GetAlpha() * G * G / pow(dispertion, 5);
//     float secondPart = exp(-1.25 * pow(peekDispertion / dispertion, 4));
//     float thirdPart = pow(abs(PeekEnhancementFactor), r);
//
//     return firstPart * secondPart * thirdPart;
// }

float PhillipsSpectrum(float2 waveVector)
{
    float A = 0.6858;
    float L = WindSpeed * WindSpeed / G;
    
    float kLength = length(waveVector);
    float dominator = exp(-1 / pow(kLength*L, 2));
    float nominator = kLength * kLength * kLength * kLength;
    float lastPart = dot(waveVector, WindDirection);
    float surpression = exp(-pow(kLength * 0.001f, 2));

    return A * exp(dominator / nominator) * (lastPart * lastPart) * surpression;
    
}

float WaveDispertion(float kLength)
{
    return sqrt(G * kLength * tanh(min(kLength * Depth, 20)));
}

float FourierWaveAmplitude(float2 pos, float2 k)
{
    //float kMagnetude = length(k);
    //float dispertion = WaveDispertion(kMagnetude);

    float rand1 = Noise[pos.xy].x;
    float rand2 = Noise[pos.xy].y;

    return 1 / sqrt(2) * (rand1 + rand2) * sqrt(PhillipsSpectrum(k));
}

float2 WaveVector(float2 pos)
{
    float n = Size / 2;
    float k_x = 2 * PI * (pos.x - n) / LengthScale;
    float k_z = 2 * PI * (pos.y - n) / LengthScale;
    return float2(k_x, k_z);
}

// float2 WaveVector(float2 pos)
// {
//     float deltaK = 2 * PI / LengthScale;
//     int nx = id.x - Size / 2;
//     int nz = id.y - Size / 2;
//     return  float2(nx, nz) * deltaK;
// }

float2 EulerFormula(float x)
{
    return float2(cos(x), sin(x));
}

float2 ComplexMult(float2 a, float2 b)
{
    float2 result;
    result.x = a.x * b.x - a.y * b.y;
    result.y = a.x * b.y + a.y * b.x;
    return result;
}

[numthreads(8,8,1)]
void CalculateSpectrum (uint3 id : SV_DispatchThreadID)
{
    float2 k = WaveVector(id.xy);

    // init
    float h_0 = FourierWaveAmplitude(id.xy, k);
    float h_1 = FourierWaveAmplitude(id.xy, -k);
    
    // real time
    float t = 3;
    float dispertion = WaveDispertion(length(k));
    float phase = dispertion * t;
    float2 exponent_0 = EulerFormula(phase);
    float2 exponent_1 = EulerFormula(-phase);
    
    // float2 firstPart = ComplexMult(h_0, exponent_0);
    // float2 secondPart = ComplexMult(h_1, exponent_1);
    // float2 h = firstPart + secondPart;

    SpectrumMap[id.xy] = float4(exponent_0.x, exponent_0.y, 0, 1);
}

[numthreads(8,8,1)]
void CalculateHeight (uint3 id : SV_DispatchThreadID)
{
    float sum = 0;

    float n = Size / 2;
    float2 pos = float2((id.x - n) * LengthScale / Size, (id.y - n) * LengthScale / Size);

    for (int x = 0; x < Size; x++)
    {
        for (int y = 0; y < Size; y++)
        {
            float2 spectrumPos = float2(x, y);
            float2 k = SpectrumMap[spectrumPos].yz;
            float h = SpectrumMap[spectrumPos].x;
            
            sum += h * exp(dot(k, pos));
        }
    }
    
    HeightMap[id.xy] = float4(sum, 0, 0, 1);
}
