#pragma kernel CalculateSpectrum
#pragma kernel CalculateHeight

#define PI 3.14159265359
#define G 9.81

// ====== Inputs ======
uint Size; // M and N
uint LengthScale;
float Depth; // this should be surface's height map

//Spectrum settings
float WindSpeed;
float Fetch;
float PeekEnhancementFactor;

// Gaussian noise
Texture2D<float2> Noise;

// ====== Outputs ======
RWTexture2D<float4> SpectrumMap;
RWTexture2D<float4> HeightMap;

float GetAlpha()
{
    float nominator = WindSpeed * WindSpeed;
    float denominator = G * Fetch;
    return 0.076f * pow(abs(nominator / denominator), 0.22f);
}

float GetPeekDispertion()
{
    float nominator = G * G;
    float denominator = WindSpeed * Fetch;
    return 22 * pow(abs(nominator / denominator), 0.333f);
}

float JONSWAP(float dispertion)
{
    float peekDispertion = GetPeekDispertion();
    float sigma = dispertion <= peekDispertion ? 0.07 : 0.09;
    float rNominator = (dispertion - peekDispertion) * (dispertion - peekDispertion);
    float rDenominator = 2 * sigma * sigma * peekDispertion * peekDispertion;
    float r = exp(-rNominator / rDenominator);
    
    float firstPart = GetAlpha() * G * G / pow(dispertion, 5);
    float secondPart = exp(-1.25 * pow(peekDispertion / dispertion, 4));
    float thirdPart = pow(abs(PeekEnhancementFactor), r);

    return firstPart * secondPart * thirdPart;
}

float WaveDispertion(float kLength)
{
    return sqrt(G * kLength * tanh(min(kLength * Depth, 20)));
}

float FourierWaveAmplitude(float2 pos, float2 k)
{
    float kMagnetude = length(k);
    float dispertion = WaveDispertion(kMagnetude);

    float rand1 = Noise[pos.xy].x;
    float rand2 = Noise[pos.xy].y;

    return 1 / sqrt(2) * (rand1 + rand2) * sqrt(JONSWAP(dispertion));
}

float2 WaveVector(float2 pos)
{
    float n = Size / 2;
    float k_x = 2 * PI * (pos.x - n) / LengthScale;
    float k_z = 2 * PI * (pos.y - n) / LengthScale;
    return float2(k_x, k_z);
}

// float2 WaveVector(float2 pos)
// {
//     float deltaK = 2 * PI / LengthScale;
//     int nx = id.x - Size / 2;
//     int nz = id.y - Size / 2;
//     return  float2(nx, nz) * deltaK;
// }

float2 EulerFormula(float x)
{
    return float2(cos(x), sin(x));
}

float2 ComplexMult(float2 a, float2 b)
{
    return float2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
}

[numthreads(8,8,1)]
void CalculateSpectrum (uint3 id : SV_DispatchThreadID)
{
    float2 k = WaveVector(id.xy);

    // init
    float h_0 = FourierWaveAmplitude(id.xy, k);
    //float h_1 = FourierWaveAmplitude(id.xy, -k);
    
    // real time
    // float t = 1;
    // float2 dispertion = WaveDispertion(length(k));
    // float2 exponent_0 = EulerFormula(dispertion * t);
    // float2 exponent_1 = EulerFormula(-dispertion * t);
    //
    // float2 firstPart = ComplexMult(h_0, exponent_0);
    // float2 secondPart = ComplexMult(h_1, exponent_1);
    // float2 h = firstPart + secondPart;

    SpectrumMap[id.xy] = float4(h_0, k.x, k.y, 1);
}

[numthreads(8,8,1)]
void CalculateHeight (uint3 id : SV_DispatchThreadID)
{
    float sum = 0;

    float n = Size / 2;
    float2 pos = float2((id.x - n) * LengthScale / Size, (id.y - n) * LengthScale / Size);

    for (int x = 0; x < Size; x++)
    {
        for (int y = 0; y < Size; y++)
        {
            float2 spectrumPos = float2(x, y);
            float2 k = SpectrumMap[spectrumPos].yz;
            float h = SpectrumMap[spectrumPos].x;
            
            sum += h * exp(dot(k, pos));
        }
    }
    
    HeightMap[id.xy] = float4(sum, 0, 0, 1);
}
