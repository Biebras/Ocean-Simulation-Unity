#pragma kernel CalculateInitSpectrum
#pragma kernel CalculateFrequencyDomain
#pragma kernel ComputeWrapper

#define PI 3.14159265359
#define G 9.81

// ====== Inputs ======
uint Size; // M and N
uint LengthScale;

//Spectrum settings
float Amplitude;
float WindSpeed;
float2 WindDirection;
float Depth;
float Time;
float DisplacementFactor;

// Gaussian noise
Texture2D Noise;

// ====== Outputs ======
RWTexture2D<float4> InitSpectrum;
RWTexture2D<float2> FrequencyDomain;
RWTexture2D<float4> WaveData;
RWTexture2D<float2> HeightMap;
RWTexture2D<float2> TangentMap;
RWTexture2D<float2> BitangentMap;
RWTexture2D<float4> NormalMap;
RWTexture2D<float2> DisplacementMapX;
RWTexture2D<float2> DisplacementMapZ;

float PhillipsSpectrum(float2 waveVector)
{
    float L = WindSpeed * WindSpeed / G;
    float l = L / 2000000;
    
    float kLength = length(waveVector);

    if(kLength < 0.0001)
        return 0;
    
    float dominator = exp(-1 / (kLength * kLength * L * L));
    float nominator = kLength * kLength * kLength * kLength;
    float k_dot_w = dot(normalize(waveVector), WindDirection);
    float surpression = exp(-kLength * kLength * l * l);
    float k_dot_w_6 = k_dot_w * k_dot_w * k_dot_w * k_dot_w * k_dot_w * k_dot_w;
    float result = Amplitude * dominator / nominator * k_dot_w_6 * surpression; 
    
    return result;
}

float WaveDispertion(float kLength)
{
    return sqrt(G * kLength * tanh(min(kLength * Depth, 20)));
    //return sqrt(G * kLength);
}

float2 FourierWaveAmplitude(float2 pos, float2 k)
{
    float2 rand = float2(Noise[pos.xy].x, Noise[pos.xy].y);

    return 1 / sqrt(2) * rand * sqrt(PhillipsSpectrum(k));
}

float2 FourierWaveAmplitudeConj(float2 pos, float2 k)
{
    float2 rand = float2(Noise[pos.xy].z, Noise[pos.xy].w);

    return 1 / sqrt(2) * rand * sqrt(PhillipsSpectrum(k));
}

float2 WaveVector(float2 pos)
{
    float n = Size / 2;
    float k_x = 2 * PI * (pos.x - n) / LengthScale;
    float k_z = 2 * PI * (pos.y - n) / LengthScale;
    
    return float2(k_x, k_z);
}

float2 EulerFormula(float x)
{
    return float2(cos(x), sin(x));
}

float2 ComplexMult(float2 a, float2 b)
{
    float2 result;
    result.x = a.x * b.x - a.y * b.y;
    result.y = a.x * b.y + a.y * b.x;
    return result;
}

[numthreads(8,8,1)]
void CalculateInitSpectrum (uint3 id : SV_DispatchThreadID)
{
    float2 k = WaveVector(id.xy);
    float kLength = length(k);
    float dispertion = WaveDispertion(kLength);
    
    float2 h_0 = FourierWaveAmplitude(id.xy, k);
    float2 h_1 = FourierWaveAmplitudeConj(id.xy, -k); 
    
    InitSpectrum[id.xy] = float4(h_0.x, h_0.y, h_1.x, h_1.y);
    WaveData[id.xy] = float4(k.x, k.y, dispertion, 1);
}

uint BitReverse(uint n)
{
    uint r = 0;
    for (uint i = 0; i < log2(Size); ++i)
    {
        r = (r << 1) | (n & 1);
        n >>= 1;
    }
    return r;
}

[numthreads(8,8,1)]
void CalculateFrequencyDomain (uint3 id : SV_DispatchThreadID)
{
    // Shift frequencies from the center
    // uint2 shiftedIndex;
    // shiftedIndex.x = (id.x + Size / 2) % Size;
    // shiftedIndex.y = (id.y + Size / 2) % Size;
    
    // init spectrum
    float2 h_0 = InitSpectrum[id.xy].xy;
    // conjugate init spectrum
    float2 h_1 = InitSpectrum[id.xy].zw;
    // w(k)
    float dispertion = WaveData[id.xy].z;
    float2 k =  WaveData[id.xy].xy;
    float oneOverKLength = 1 / max(0.001, length(k));
    
    // real time
    float phase = dispertion * Time;
    float2 exponent_0 = EulerFormula(phase);
    float2 exponent_1 = EulerFormula(-phase);
    
    float2 firstPart = ComplexMult(h_0, exponent_0);
    float2 secondPart = ComplexMult(h_1, exponent_1);
    float2 h = (firstPart + secondPart) / (Size * Size);
    float2 ih = float2(-h.y, h.x);
    
    float2 tangent = ih * k.x;
    float2 bitangent = ih * k.y;
    float2 vectorFieldX = -DisplacementFactor * ih * -k.x * oneOverKLength;
    float2 vectorFieldZ = -DisplacementFactor * ih * -k.y * oneOverKLength;
    
    FrequencyDomain[id.xy] = float2(h.x, h.y) * (Size * Size);
    HeightMap[id.xy] = float2(h.x, h.y);
    TangentMap[id.xy] = float2(tangent.x, tangent.y);
    BitangentMap[id.xy] = float2(bitangent.x, bitangent.y);
    DisplacementMapX[id.xy] = float2(vectorFieldX.x, vectorFieldX.y);
    DisplacementMapZ[id.xy] = float2(vectorFieldZ.x, vectorFieldZ.y);
}

[numthreads(8,8,1)]
void ComputeWrapper (uint3 id : SV_DispatchThreadID)
{
    float bitangent = BitangentMap[id.xy].x;
    float tangent = TangentMap[id.xy].x;
    float3 normal = normalize(float3(-tangent, 1, -bitangent));

    NormalMap[id.xy] = float4(normal.x, normal.y, normal.z, 1);
}