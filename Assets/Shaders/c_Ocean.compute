#pragma kernel CSMain

#define PI 3.14159265359
#define G 9.81

// Inputs
int Size;
int Resolution;
float WindSpeed;
float DistanceFromShore;
Texture2D<float2> Noise;

// Outputs
RWTexture2D<float4> Result;

float JONSWAP(float angularFrequency)
{
    float alpha = 0.076 * pow(pow(WindSpeed, 2) / (DistanceFromShore * G), 0.22); 
    float gamma = 3.3;
    float peakFrequency = 22 * (pow(G, 2) / (WindSpeed * DistanceFromShore));
    float sigma = angularFrequency <= peakFrequency ? 0.07 : 0.09;

    float r_1 = 2 * sigma * sigma * peakFrequency * peakFrequency;
    float r_2 = (angularFrequency - peakFrequency) * (angularFrequency - peakFrequency);
    float r = exp(-r_1 / r_2);
    float peakEnhancement = pow(gamma, r);

    return alpha * G * G / pow(angularFrequency, 5)
                 * exp(-1.25 * pow(peakFrequency / angularFrequency, 4))
                 * peakEnhancement; 
}

float WaveDispertion(float kMag)
{
    float oceanDepth = 1000;
    return sqrt(G * kMag * tanh(min(kMag * oceanDepth, 15)));
}

float WaveHeight(float kMagnetude, float2 pos)
{
    float angularFrequency = WaveDispertion(kMagnetude);

    float rand1 = Noise[pos.xy].x;
    float rand2 = Noise[pos.xy].y;

    return 1 / sqrt(2) * (rand1 + rand2) * sqrt(JONSWAP(angularFrequency));
}

float2 WaveVector(float2 pos)
{
    float n = Resolution / 2;
    float k_x = 2 * PI * (pos.x - n) / Size;
    float k_z = 2 * PI * (pos.y - n) / Size;
    return  float2(k_x, k_z);
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // offset to center
    float2 k = WaveVector(id.xy);
    float kMagnetude = length(k);
    float height = WaveHeight(kMagnetude, id.xy);
    
    Result[id.xy] = float4(height, 0, 0, 1);
}
