// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CalculateInitSpectrum
#pragma kernel ConjugateInitSpectrum

#define PI 3.1415926
#define G 9.81

// Inputs
uint Size;
uint LengthScale;
float LowerCutOff;
float UpperCutOff;
Texture2D Noise;

float WindSpeed;
float WindAngle;
float Swell;
float Fetch;
float Depth;

// Outputs
RWTexture2D<float2> InitSpectrum;
RWTexture2D<float4> ConjugatedSpectrum;
RWTexture2D<float4> WaveData;

float DispersionPeak()
{
    return 22 * pow(G * G / (WindSpeed * Fetch), 0.33);
}

float WaveDispersion(float kLength)
{
    return sqrt(G * kLength);
}

float DispersionDerivative(float kLength)
{
    return G / (2 * sqrt(G * kLength));
}

float fmod(float a, float b)
{
    return a - b * floor(a / b);
}

float GammaApprox(float x)
{
    float g2 = x * x;
    float g3 = g2 * x;
    float g4 = g3 *x;
    
    return g4;
}

float WaveAngle(float2 k)
{
    const float windAngle = WindAngle / 180 * PI;
    float angle = atan2(k.y, k.x) - windAngle;

    // Normalize the angle to the range [-PI, PI]
    angle = fmod(angle + PI, 2 * PI);
    if (angle < 0)
        angle += 2 * PI;
    return angle - PI;
}

float TMACorrection(float dispersion)
{
    float omegaH = dispersion * sqrt(Depth / G);

    if(omegaH <= 1)
        return 0.5 * omegaH * omegaH;
    if(omegaH < 2)
        return 1 - 0.5 * (2 - omegaH) * (2 - omegaH);
    
    return 1; 
}

float JONSWAP(float dispersion)
{
    float alpha = 0.076 * pow(WindSpeed * WindSpeed / (Fetch * G), 0.22);
    float omega_p = DispersionPeak();
    float sigma = dispersion <= omega_p ? 0.07 : 0.09;
    float r = exp(-(dispersion - omega_p) * (dispersion - omega_p) / (2 * sigma * sigma * omega_p * omega_p));
    
    float firstPart = alpha * G * G / (dispersion * dispersion * dispersion * dispersion * dispersion);
    float secondPart = exp(-1.25 * pow(omega_p / dispersion, 4));
    float thirdPart = pow(3.3, r);

    return TMACorrection(dispersion) * firstPart * secondPart * thirdPart;
}

float NormalisationFactor(float s)
{
    // float gamma1 = GammaApprox(s + 1);
    // float gamma2 = GammaApprox(2 * s + 1);
    //
    // float firstPart = pow(2, 2 * s - 1) / PI;
    // float secondPart = gamma1 * gamma1 / gamma2;
    //
    // return firstPart * secondPart;

    float s2 = s * s;
    float s3 = s2 * s;
    float s4 = s3 * s;
    
    if (s < 5)
        return -0.000564 * s4 + 0.00776 * s3 - 0.044 * s2 + 0.192 * s + 0.163;
    else
        return -4.80e-08 * s4 + 1.07e-05 * s3 - 9.53e-04 * s2 + 5.90e-02 * s + 3.93e-01;
}

float SwellSpread(float dispersion, float angle)
{
    const float s = 16 * tanh(DispersionPeak() / dispersion) * Swell * Swell;
    const float norm = NormalisationFactor(s);
    
    return norm * pow(abs(cos(angle / 2)), 2 * s);
}

float BaseSpread(float dispersion, float angle)
{
    float omega_p = DispersionPeak();
    float omegaOverOmegaPeek = dispersion / omega_p;
    float beta;

    if(omegaOverOmegaPeek < 0.95)
    {
        beta = 2.61 * pow(omegaOverOmegaPeek, 1.3);
    }
    else if(0.95 <= omegaOverOmegaPeek && omegaOverOmegaPeek <= 1.6)
    {
        beta = 2.28 * pow(omegaOverOmegaPeek, -1.3);
    }
    else
    {
        float epsilon = -0.4 + 0.8393 * exp(-0.567 * log(omegaOverOmegaPeek * omegaOverOmegaPeek));
        beta = pow(10, epsilon);
    }
    
    float sech = 1 / cosh(beta * angle);
    
    float firstPart = beta / (2 * tanh(beta * PI));
    float secondPart = sech * sech;

    return firstPart * secondPart;
}

// float DirectionNormal(float2 a, float2 b, int n)
// {
//     float base = BaseSpread(dispersion, angle);
//     float swell = SwellSpread(dispersion, angle);
//     float func = base * swell;
//
//     float2 h = (b - a) / n;
//     float4 s = f(a) + f(b);
//     for (int i = 1; i < n; i++)
//     {
//         s += 2 * f(a + i * h);
//     }
//     return length(h) / 2 * s;
// }

float DirectionalSpread(float dispersion, float angle)
{
    float base = BaseSpread(dispersion, angle);
    float swell = SwellSpread(dispersion, angle);
    return base;
}


float Spectrum(float kLength, float dispersion, float angle)
{
    return JONSWAP(dispersion) * DirectionalSpread(dispersion, angle) * DispersionDerivative(kLength) / kLength;
}

float2 FourierWaveAmplitude(float2 pos, float2 k, float dispersion, float angle)
{
    float deltaK = 2 * PI / LengthScale;
    float kLength = length(k);
    float2 rand = float2(Noise[pos.xy].x, Noise[pos.xy].y);

    return rand * sqrt(2 * Spectrum(kLength, dispersion, angle) * deltaK * deltaK);
}

float2 WaveVector(float2 pos)
{
    float n = Size / 2;
    float k_x = 2 * PI * (pos.x - n) / LengthScale;
    float k_z = 2 * PI * (pos.y - n) / LengthScale;
    float2 k = float2(k_x, k_z);

    if (length(k) == 0)
    {
        k.x = 0.0001;
        k.y = 0.0001;
    }
    
    return k;
}

[numthreads(8,8,1)]
void CalculateInitSpectrum (uint3 id : SV_DispatchThreadID)
{
    float2 k = WaveVector(id.xy);
    float kLength = length(k);
    float dispersion = WaveDispersion(kLength);
    float angle = WaveAngle(k);

    if(kLength > LowerCutOff && kLength < UpperCutOff)
    {
        float2 h_0 = FourierWaveAmplitude(id.xy, k, dispersion, angle);
        InitSpectrum[id.xy] = float2(h_0.xy);
        WaveData[id.xy] = float4(k.x, k.y, dispersion, 1);
    }
    else
    {
        InitSpectrum[id.xy] = float2(0, 0);
        WaveData[id.xy] = float4(k.x, k.y, 1, 1);
    }
}

[numthreads(8,8,1)]
void ConjugateInitSpectrum (uint3 id : SV_DispatchThreadID)
{
    float2 h_0 = InitSpectrum[id.xy];
    float2 h_minus_k = InitSpectrum[uint2((Size - id.x) % Size, (Size - id.y) % Size)];
    ConjugatedSpectrum[id.xy] = float4(h_0.xy, h_minus_k.x, -h_minus_k.y);
}
